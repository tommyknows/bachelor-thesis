% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

In the last decade, concepts from functional programming have grown in
importance within the wider, non-functional programming community.
Often it is recommended to learn a purely functional programming language
like Haskell to become familiar with these concepts.
However, many programmers struggle with the double duty
of learning a new paradigm and a new syntax at the same time. Because of
this, this paper expands on the idea of learning purely functional programming
with a multi-paradigm programming language and a familiar syntax. Go
is the language of choice for this due to its syntactical symplicity
and familiarity.

The absence of a list datatype in Go is remediated by Go's slices.
However, Go is missing the typical higher-order functions ---
`map', `filter' and `fold' to name a few --- that are present in every
functional programming language and many other programming languages too.
Due to the absence of polymorphism in Go, the most popular higher-order
functions are added to the built-in functions in the compiler.

Furthermore, this paper specifies a definition of what pure functional programming is and
introduces `funcheck', a static code analysis tool that is designed to
report constructs that are non-functional.

With the help of the newly built-in functions `fmap', `filter', `foldr', `foldl' and
`prepend', as well as `funcheck' to lint code, Go proves itself to be a
suitable language for getting started with functional programming.
At the same time, it also shows that there is no way around learning a
language like Haskell if fluency with functional programming concepts
is desired. The primary reasons are that, although it may be unusual, Haskell's
syntax is extremely concise, and that the language's design --- the type system,
pattern matching, the purity guarantees and more --- provides a very effective toolset
for purely functional programming.
