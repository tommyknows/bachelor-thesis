% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

\section{Refactoring the Prettyprint Package}

\newglossaryentry{stdout}{name=stdout, description={Standard Output, the default
output stream for programs}}

The code blocks~\ref{code:assign-pos} and~\ref{code:func-reassign} have been
generated by a small package `prettyprint' contained in the funcheck repository.

The prettyprinter is based on the same framework as assigncheck\footnote{Assigncheck
is the main package for funcheck and checks the reassignments}, but instead
of reporting anything, it prints AST information to \gls{stdout}.

Similarily to assigncheck, the main logic of the package is within a
function literal that is being passed to the \mintinline{go}|ast.Inspect|
function.

Prettyprint only checks two AST node types, \mintinline{go}|*ast.DeclStmt|
(declarations) and \mintinline{go}|*ast.AssignStmt| (assignments).

For example, for the program
\begin{gocode}
package main

import "fmt"

func main() {
	x, y := 1, 2
	y = 3
	fmt.Println(x, y)
}
\end{gocode}
the following AST information is printed:

\begin{gocode}
Assignment "x, y := 1, 2": 2958101
		Ident "x": 2958101
				Decl "x, y := 1, 2": 2958101
		Ident "y": 2958104
				Decl "x, y := 1, 2": 2958101
Assignment "y = 3": 2958115
		Ident "y": 2958115
				Decl "x, y := 1, 2": 2958101
\end{gocode}
The package is written in what could be considered idiomatic Go\footnote{Although
there is no exact definition of what idiomatic Go is, so this interpretation could
be challenged. It is idiomatic Go code to the author of this thesis}. %TODO?

When running funcheck on this package, it reports the following errors:

\begin{bashcode}
$> funcheck .
prettyprint.go:20:2: internal reassignment (for loop) in "for _, file := range pass.Files { ... }"
prettyprint.go:30:5: internal reassignment (for loop) in "for i := range decl.Specs { ... }"
prettyprint.go:53:5: internal reassignment (for loop) in "for _, expr := range as.Lhs { ... }"
\end{bashcode}
As can be seen in the output, the package uses a couple of for loops to range over
slices. However, there are no re-assignments of variables to be found.

The code to print declarations is as shown in~\ref{code:decl-printing}.

\begin{code}
	\captionof{listing}{Pretty-printing declarations in idiomatic Go}
	\label{code:decl-printing}
\begin{gocode}
func checkDecl(as *ast.DeclStmt, fset *token.FileSet) {
	fmt.Printf("Declaration %q: %v\n", render(pass.Fset, as), as.Pos())
	decl, ok := as.Decl.(*ast.GenDecl)
	if !ok {
		break
	}

	for i := range decl.Specs {
		val, ok := decl.Specs[i].(*ast.ValueSpec)
		if !ok {
			continue
		}

		if val.Values != nil {
			continue
		}

		if _, ok := val.Type.(*ast.FuncType); !ok {
			continue
		}

		fmt.Printf("\tIdent %q: %v\n", render(pass.Fset, val), val.Names[0].Pos())
	}
}
\end{gocode}
\end{code}
To convert this for-loop appropriately, the new built-in `foldl' can be used.
To recapitulate, the `foldl' function is being defined as:
\begin{gocode}
func foldl(fn func(Type1, Type) Type1, acc Type1, slice []Type) Type1
\end{gocode}
As `foldl' requires a return type, we introduce a dummy type `null', which
is just an empty struct:
\begin{gocode}
type null struct{}
\end{gocode}
Now the code within the foor loop can be used to create a function literal:
\begin{gocode}
check := func(_ null, spec ast.Spec) (n null) {
	// implementation
}
\end{gocode}
There are two subtleties in regards to the introduced null type:
First, the null value that is being passed as an argument is being discarded
by the use of an empty identifier.
Secondly, the return value is `named', which means the variable `n' is
already declared in the function block. Because of this, `naked returns' can
be used, so there is no need to specify which variable is being returned.

The snippet~\ref{code:decl-printing} thus can be translated to

\begin{code}
	\captionof{listing}{Pretty-printing declarations in functional Go}
	\begin{gocode}
func checkDecl(as *ast.DeclStmt, fset *token.FileSet) {
	fmt.Printf("Declaration %q: %v\n", render(fset, as), as.Pos())

	check := func(_ null, spec ast.Spec) (n null) {
		val, ok := spec.(*ast.ValueSpec)
		if !ok {
			return
		}
		if val.Values != nil {
			return
		}
		if _, ok := val.Type.(*ast.FuncType); !ok {
			return
		}
		fmt.Printf("\tIdent %q: %v\n", render(fset, val), val.Names[0].Pos())
		return
	}

	if decl, ok := as.Decl.(*ast.GenDecl); ok {
		_ = foldl(check, null{}, decl.Specs)
	}
}
\end{gocode}
\end{code}
The for-loop has been replaced by a `foldl', where we pass a function closure
that contains the actual processing.

While this still looks similar to the original example, this is mostly due to
the `if' statements. In Haskell, pattern matching would be used and nil checks
could be omitted entirely. Also, as Haskell's type system is more advanced, the
handling of those would be different too.

However, the goal of this thesis is to make functional code look more familiar
to programmers that are used to imperative code.
And while it may not look like it, the code does not use any mutation of
variables\footnote{Libraries may do, but the scope is not to rewrite the entire
standard library}, for loops or global state. Therefore, it can be concluded that this
snippet is purely functional as per the definition from Chapter~\ref{sec:func-purity}.

\section{Quicksort}

In Chapter~\ref{code:haskell-quicksort}, a naive implementation of the Quicksort sorting
algorithm has been introduced.
Implementing this algorithm in Go is now straightforward and the similarities between
the Haskell implementation and the functional Go implementations are striking:

\begin{code}
	\gofilerange{../work/examples/go-quicksort/main.go}{start-quicksort}{end-quicksort}
\end{code}

Again, this implementation bridges the gap between being imperative and functional,
while still being obvious about the algorithm.
Furthermore, as expected, when inspecting the code with funcheck, no non-functional
constructs are reported.
