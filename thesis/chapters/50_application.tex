% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

\section{Refactoring the Prettyprint Package}

\newglossaryentry{stdout}{name=stdout, description={Standard Output, the default
output stream for programs}}

The code blocks~\ref{code:assign-pos} and~\ref{code:func-reassign} have been
generated by a small package `prettyprint' contained in the funcheck repository.

To see how the newly bult-in functions and funcheck can be used, we refactor `prettyprint'
to a purely functional version.
The current version of the package is written in what could be considered idiomatic
Go\footnote{
	Although there is no exact definition of what idiomatic Go is, so this interpretation
	could be challenged. It is idiomatic Go code to the author of this thesis.
}. %TODO?


The prettyprinter is based on the same framework as assigncheck\footnote{Assigncheck
is the main package for funcheck and checks the reassignments}, but instead
of reporting anything, it prints AST information to \gls{stdout}.

Similarily to assigncheck, the main logic of the package is within a
function literal that is being passed to the \mintinline{go}|ast.Inspect|
function.

Prettyprint only checks two AST node types, \mintinline{go}|*ast.DeclStmt|
(declarations) and \mintinline{go}|*ast.AssignStmt| (assignments).

For example, for the program
\begin{gocode}
package main

import "fmt"

func main() {
	x, y := 1, 2
	y = 3
	fmt.Println(x, y)
}
\end{gocode}
the following AST information is printed:

\begin{gocode}
Assignment "x, y := 1, 2": 2958101
		Ident "x": 2958101
				Decl "x, y := 1, 2": 2958101
		Ident "y": 2958104
				Decl "x, y := 1, 2": 2958101
Assignment "y = 3": 2958115
		Ident "y": 2958115
				Decl "x, y := 1, 2": 2958101
\end{gocode}

To refactor it to a purely functional version, funcheck can be used to
list statements that are not functional:

\begin{bashcode}
$> funcheck .
prettyprint.go:20:2: internal reassignment (for loop) in "for _, file := range pass.Files { ... }"
prettyprint.go:30:5: internal reassignment (for loop) in "for i := range decl.Specs { ... }"
prettyprint.go:53:5: internal reassignment (for loop) in "for _, expr := range as.Lhs { ... }"
\end{bashcode}
As can be seen in the output, the package uses 3 `for' loops to range over
slices. However, there are no other re-assignments of variables in the code.

The code to print declarations is as shown in~\ref{code:decl-printing}.

\begin{code}
	\captionof{listing}{Pretty-printing declarations in idiomatic Go}
	\label{code:decl-printing}
\begin{gocode}
func checkDecl(as *ast.DeclStmt, fset *token.FileSet) {
	fmt.Printf("Declaration %q: %v\n", render(pass.Fset, as), as.Pos())
	decl, ok := as.Decl.(*ast.GenDecl)
	if !ok {
		break
	}

	for i := range decl.Specs {
		val, ok := decl.Specs[i].(*ast.ValueSpec)
		if !ok {
			continue
		}

		if val.Values != nil {
			continue
		}

		if _, ok := val.Type.(*ast.FuncType); !ok {
			continue
		}

		fmt.Printf("\tIdent %q: %v\n", render(pass.Fset, val), val.Names[0].Pos())
	}
}
\end{gocode}
\end{code}
To convert this for-loop appropriately, the new built-in `foldl' can be used.
To recapitulate, the `foldl' function is being defined as:
\begin{gocode}
func foldl(fn func(Type1, Type) Type1, acc Type1, slice []Type) Type1
\end{gocode}
As `foldl' requires a return type, we introduce a dummy type `null', which
is just an empty struct:
\begin{gocode}
type null struct{}
\end{gocode}
Now the code within the foor loop can be used to create a function literal:
\begin{gocode}
check := func(_ null, spec ast.Spec) (n null) {
	// implementation
}
\end{gocode}
There are two subtleties in regards to the introduced null type:
First, the null value that is being passed as an argument is being discarded
by the use of an empty identifier.
Secondly, the return value is `named', which means the variable `n' is
already declared in the function block. Because of this, `naked returns' can
be used, so there is no need to specify which variable is being returned.

The snippet~\ref{code:decl-printing} thus can be translated to

\begin{code}
	\captionof{listing}{Pretty-printing declarations in functional Go}
	\begin{gocode}
func checkDecl(as *ast.DeclStmt, fset *token.FileSet) {
	fmt.Printf("Declaration %q: %v\n", render(fset, as), as.Pos())

	check := func(_ null, spec ast.Spec) (n null) {
		val, ok := spec.(*ast.ValueSpec)
		if !ok {
			return
		}

		if val.Values != nil {
			return
		}

		if _, ok := val.Type.(*ast.FuncType); !ok {
			return
		}

		fmt.Printf("\tIdent %q: %v\n", render(fset, val), val.Names[0].Pos())
		return
	}

	if decl, ok := as.Decl.(*ast.GenDecl); ok {
		_ = foldl(check, null{}, decl.Specs)
	}
}
\end{gocode}
\end{code}
The for-loop has been replaced by a `foldl', where we pass a function closure
that contains the actual processing.

While this still looks similar to the original example, this is mostly due to
the `if' statements. In Haskell, pattern matching would be used and nil checks
could be omitted entirely. Also, as Haskell's type system is more advanced, the
handling of those would be different too.

However, the goal of this thesis is to make functional code look more familiar
to programmers that are used to imperative code.
And while it may not look like it, the code does not use any mutation of
variables\footnote{Libraries may do, but the scope is not to rewrite any existing
libraries.}, for loops or global state. Therefore, it can be concluded that this
snippet is purely functional as per the definition from Chapter~\ref{sec:func-purity}.

\section{Quicksort}

In Chapter~\ref{code:haskell-quicksort}, a naive implementation of the Quicksort sorting
algorithm has been introduced.
Implementing this algorithm in Go is now straightforward and the similarities between
the Haskell implementation and the functional Go implementation are striking:

\begin{code}
	\captionof{listing}{Quicksort Implementations compared}
	\begin{gocode}
func quicksort(p []int) []int {
	if len(p) == 0 {
		return []int{}
	}

	lesser := filter(func(x int) bool { return p[0] > x }, p[1:])
	greater := filter(func(x int) bool { return p[0] <= x }, p[1:])

	return append(quicksort(lesser), prepend(p[0], quicksort(greater))...)
}
\end{gocode}
\begin{haskellcode}
quicksort :: Ord a => [a] -> [a]
quicksort []     = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs
\end{haskellcode}
\end{code}

Again, the Go implementation bridges the gap between being imperative and functional,
while still being obvious about the algorithm.
Furthermore, as expected, when inspecting the code with funcheck, no non-functional
constructs are reported.

\section{Comparison to Java Streams}

In Java 8, concepts from functional programing have been introduced to the language.
The major new feature was Lambda Expressions --- anonymous function literals --- and
streams. Streams are an abstract layer to process data in a functional way, with `map',
`filter', `reduce' and more.

It is similar to the new built-in functions in this thesis:

\begin{code}
	\captionof{listing}{Comparision Java Streams and Functional Go}
	\begin{javacode}
List<Integer> even = list.stream()
	.filter(x -> x % 2 == 0)
	.collect(Collectors.toList());
	\end{javacode}
	\begin{gocode}
even := filter(
	func(x int) bool { return x%2 == 0 },
	list)
	\end{gocode}
\end{code}

The lambda-syntax in Java is more concise than Go's function literals, where the
complete function header has to be provided\footnote{There is an open proposal
	to add a lightweight anonymous function syntax to Go 2, which, if implemented,
would resolve the verbosity\autocite{go-lambdas}}. Java also has a more verbose way
to declare anonymous functions, which is creating an anonymous class:

\begin{javacode}
printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);
\end{javacode}
\autocite{java-lambda-expressions}

If this is used, Go's function literal syntax has an edge over Java's when it comes to
readability and conciseness.

Furthermore, the conversion to a stream and back to a list
(\mintinline{java}|list.stream()| and \mintinline{java}|.collect(Collectors.toList())|)
is not required in Go, as the operations all work on slices. Here, only having a single
list-like type built into the language is an advantage, as the mental overhead to convert
the list only to run a `filter' function can be avoided.

Apart from syntactical differences, Java Streams contain all the functions that
have been added as built-ins to Go too, and more.

However, Java's Syntax is arguably more complex than Go. An indicator for this might be
the language specification; Go's Language Specification is roughly 110 pages, while
Java's specification is more than 700 pages\footnote{
	The Java 8 Specification is 724\autocite{java-8-spec}, the Java 14
	Specification 774\autocite{java-14-spec} pages. An interesting sidenote may
	be that Go's specification grew by roughly 15 pages in 8 years (Go 1.0.0, 2012 - Go
	1.14.0, 2020), Java's by almost 170 pages between Java 7 (2013) and Java 14 (2020).
},
more than 6 times the size.
