% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

Innerhalb der letzten zehn Jahre haben Konzepte und Ideen aus dem funktionalen
Programmieren im Alltag von vielen Entwicklern Fuss gefasst. Häufig wird
empfohlen, eine pur funktionale Programmiersprache wie zum Beispiel Haskell
zu lernen, um sich mit diesen Konzepten vertraut zu machen. Viele haben jedoch
Mühe, eine neue Syntax und ein neues Paradigma gleichzeitig zu lernen. Das Ziel
dieser Arbeit ist deswegen, einen einfacheren Einstieg in funktionales Programmieren
zu ermöglichen, dies mit Hilfe einer multiparadigmatischen Programmiersprache mit bekannter
Syntax.

Um dieses Ziel zu erreichen, wurde die Programmiersprache Go aufgrund ihrer
syntaktischen Simplizität und Vertrautheit gewählt.
Da Listen jedoch oft eine zentrale Rolle im funktionalen Programmieren einnehmen, ist ein
Nachteil dieser Wahl, dass Go keinen eingebauten List Datentyp besitzt. Zwar wird
dieser Nachteil durch Go's `Slices' gemildert, jedoch fehlen viele sogenannte `higher-order'
Funktionen um mit Listen zu arbeiten --- `map', `filter' und `reduce', um einige zu nennen.
Da Go's Typensystem keinen Polymorphismus bietet, müssen diese Funktionen im Compiler
implementiert werden, um eine möglichst benutzerfreundliche Verwendung zu ermöglichen.

Zusätzlich dazu wird die Bedeutung von `pure functional Programming' im Kontext dieser Arbeit
festgelegt und auf Basis dieser Definition das Code-Analyse Tool `funcheck' entwickelt, welches
nicht-funktionale Konstrukte im Programmcode meldet.

Mit den neuen built-in Funktionen `fmap', `filter', `foldr', `foldl' und `prepend',
sowie dem Linter `funcheck' erweist sich Go als geeignete Programmiersprache um
einen einfachen Einstieg in funktionales Programmieren zu ermöglichen. Der primäre Grund
spiegelt sich auch im Go Idiom `clear is better than clever' wider. Obwohl funktionaler
Go Code länger ist als in funktionalen Sprachen, ist dieser auch einfacher nachzuvollziehen.
Des Weiteren zeigt die Arbeit aber auch, dass es keinen Weg um eine pure funktionale Sprache
wie Haskell gibt, um sich funktionales Programmieren vollständig anzueignen.
Haskell's zwar ungewöhnliche, aber prägnante Syntax sowie das Design
der Sprache --- das Typensystem, Pattern Matching, die Purity Guarantees und vieles mehr ---
bilden hierfür eine solide und oft verwendete Grundlage.
