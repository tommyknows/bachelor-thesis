\section{Example for Functional Options}\label{appendix:funcopts}
\begin{code}
    \captionof{listing}{Functional Options for a simple Webserver}
    \gofile{../work/examples/functional-options/main.go}
\end{code}

\section{Analysis of function occurrences in Haskell code}\label{appendix:function-occurrences}
The results of the analysis have been aquired by running the following command
from the root of the git repository\cite{git-repo}:
\begin{bashcode}
./work/common-list-functions/count-function.sh "map " " : " "fold" "filter " "reverse " "take " "drop " "maximum" "sum " "zip " "product " "minimum " "reduce "
\end{bashcode}

\section{Mutating variables in Go}\label{appendix:mutation}
\begin{code}
	\captionof{listing}{Example on how to mutate complex types in Go}
	\gofile{../work/examples/mutate/main.go}
\end{code}

\section{Shadowing variables in Go}\label{appendix:shadowing}
\begin{code}
	\captionof{listing}{Example on how shadowing works on block scopes}
	\gofile{../work/examples/shadowing/main.go}
\end{code}

\section{Workaround for the missing foldl' implementation in Go}\label{appendix:foldl-go}
\begin{code}
	\captionof{listing}{Working around the missing foldl implementation in Go}
	\label{code:foldl-go}
	\gofile{../work/examples/foldl-workaround/main.go}
	\begin{bashcode}
$> fgo run .
0
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x109e945]

goroutine 1 [running]:
main.what(0x2, 0x0, 0x2)
		/tmp/map/main.go:16 +0x5
main.main()
		/tmp/map/main.go:12 +0x187
exit status 2
	\end{bashcode}
\end{code}

\section{Prettyprint implementation}\label{appendix:prettyprint-func}
\begin{code}
	\captionof{listing}{The original prettyprint implementation}
	\gofile{../work/funcheck/prettyprint/prettyprint.go}
\end{code}
\begin{code}
	\captionof{listing}{The refactored, functional prettyprint implementation}
	\begin{gocode}
package prettyprint

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"

	"golang.org/x/tools/go/analysis"
)

var Analyzer = &analysis.Analyzer{
	Name: "prettyprint",
	Doc:  "prints positions",
	Run:  run,
}

type null struct{}

func checkDecl(as *ast.DeclStmt, fset *token.FileSet) {
	fmt.Printf("Declaration %q: %v\n", render(fset, as), as.Pos())

	check := func(_ null, spec ast.Spec) (n null) {
		val, ok := spec.(*ast.ValueSpec)
		if !ok {
			return
		}
		if val.Values != nil {
			return
		}
		if _, ok := val.Type.(*ast.FuncType); !ok {
			return
		}
		fmt.Printf("\tIdent %q: %v\n", render(fset, val), val.Names[0].Pos())
		return
	}

	if decl, ok := as.Decl.(*ast.GenDecl); ok {
		_ = foldl(check, null{}, decl.Specs)
	}
}

func checkAssign(as *ast.AssignStmt, fset *token.FileSet) {
	fmt.Printf("Assignment %q: %v\n", render(fset, as), as.Pos())

	check := func(_ null, expr ast.Expr) (n null) {
		ident, ok := expr.(*ast.Ident) // Lhs always is an "IdentifierList"
		if !ok {
			return
		}

		fmt.Printf("\tIdent %q: %v\n", ident.String(), ident.Pos())

		switch {
		case ident.Name == "_":
			fmt.Printf("\t\tBlank Identifier!\n")
		case ident.Obj == nil:
			fmt.Printf("\t\tDecl is not in the same file!\n")
		default:
			// make sure the declaration has a Pos func and get it
			declPos := ident.Obj.Decl.(ast.Node).Pos()
			fmt.Printf("\t\tDecl %q: %v\n", render(fset, ident.Obj.Decl), declPos)
		}

		return
	}
	_ = foldl(check, null{}, as.Lhs)
}

func run(pass *analysis.Pass) (interface{}, error) {
	inspect := func(_ null, file *ast.File) (n null) {
		ast.Inspect(file, func(n ast.Node) bool {
			switch as := n.(type) {
			case *ast.DeclStmt:
				checkDecl(as, pass.Fset)
			case *ast.AssignStmt:
				checkAssign(as, pass.Fset)
			}
			return true
		})
		return
	}
	_ = foldl(inspect, null{}, pass.Files)

	return nil, nil
}

// render returns the pretty-print of the given node
func render(fset *token.FileSet, x interface{}) string {
	var buf bytes.Buffer
	if err := printer.Fprint(&buf, fset, x); err != nil {
		panic(err)
	}
	return buf.String()
}
	\end{gocode}
\end{code}

\section{Compiling and using functional Go}

To compile and use the changes to the Go compiler that have been implemented in
this thesis, these instructions should be followed.

First, check out the Go source code:

\begin{bashcode}
$> git clone https://github.com/tommyknows/go.git
$> cd go
$> git checkout bachelor-thesis
\end{bashcode}

\subsection{With a working Go installation}

If you already have a working Go installation on your system, the following
steps provide a way to get functional go up and running in the same way
a normal go installation does.

These steps need to be executed from within the checked out `go' git
repository on the branch `bachelor-thesis'.

Build the functional Go binary and configure the environment:
\begin{bashcode}
$> cd ./src
$> ./make.bash
$> ln -s $(realpath $(pwd)/../bin/go) /usr/local/bin/fgo
$> go env -w GOROOT=$(realpath $(pwd)/..)
\end{bashcode}

The `go env' command sets the GOROOT to point to the newly compiled tools
and source code and is valid for the current shell session only.

After these steps, the binary `fgo' can be used to test and build
functional go code. `fgo' is not different to the normal `go' command, so
all commands that work with the normal `go' command should also work with
the `fgo' command.

\begin{bashcode}
$> cd <code directory>
$> fgo test ./...
$> fgo build ./...
\end{bashcode}


\subsection{With Docker}

If Docker is installed on your system, you can follow these steps from within
the checked out `go' git repository on the branch `bachelor-thesis'.
The downside of this approach is that the installation can only be used in
the container, and directories have to be mounted into the container to compile
projects.

\begin{bashcode}
$> CODEDIR=<some directory>
$> docker build . -t fgo
$> docker run --rm --it -v $CODEDIR:/work fgo bash
\end{bashcode}
These commands build Go in the container and setup the environment. To build
projects with the functional Go installation, set \mintinline{bash}|CODEDIR|
to the path where your code resides.

Then, from within the container, the binary `fgo' can be used to test and build
functional go code. `fgo' is not different to the normal `go' command, but is the
go binary that has been compiled with the functional additions.

\begin{bashcode}
$> cd /work
$> fgo test ./...
$> fgo build ./...
\end{bashcode}


% - Add your appendix here:

\todo[inline]{
  Anhang/Appendix:

  \quad -- Projektmanagement: \\ % chktex 8
  \qquad -- Offizielle Aufgabenstellung, Projektauftrag \\ % chktex 8
  \qquad -- (Zeitplan) \\ % chktex 8
  \qquad -- (Besprechungsprotokolle oder Journals) % chktex 8

  \quad -- Weiteres: \\ % chktex 8
  \qquad -- CD/USB-Stick mit dem vollständigen Bericht als PDF-File inklusive Film- und Fotomaterial \\ % chktex 8
  \qquad -- (Schaltpläne und Ablaufschemata) \\ % chktex 8
  \qquad -- (Spezifikation u. Datenblätter der verwendeten Messgeräte und/oder Komponenten) \\ % chktex 8
  \qquad -- (Berechnungen, Messwerte, Simulationsresultate) \\ % chktex 8
  \qquad -- (Stoffdaten) \\ % chktex 8
  \qquad -- (Fehlerrechnungen mit Messunsicherheiten) \\ % chktex 8
  \qquad -- (Grafische Darstellungen, Fotos) \\ % chktex 8
  \qquad -- (Datenträger mit weiteren Daten (z. B. Software-Komponenten) inkl. Verzeichnis der auf diesem Datenträger abgelegten Dateien) \\ % chktex 8
  \qquad -- (Softwarecode) % chktex 8
}
