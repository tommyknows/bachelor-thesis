% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

\section{Slice Helper Functions}
\subsection{Implementing Prepend}

\subsubsection{Adding the GoDoc}
In Go, documentation is generated directly from comments within the source code\cite{godoc}. This also applies to
builtin functions in the compiler, which have a function stub to document their behaviour\cite{godoc-builtin},
but no implementation, as that is done in the compiler\cite{builtin-impl}.

The prepend function header is modelled after the append declaration:
\begin{code}
    \captionof{listing}{Godoc for builtin functions (\textit{src/builtin/builtin.go})}
\begin{gocode}
func append(slice []Type, elems ...Type) []Type
func prepend(elem Type, slice []Type) []Type
\end{gocode}
\end{code}

The file containing the documentation is `\textit{src/builtin/builtin.go}'.
Adding a comment above the `prepend' function header concludes the documentation
part of the implementation.

\subsubsection{Adding prepend to the public packages}

The second step is to add prepend to the `\textit{src/go/types}' package.
\begin{quote}
    Package types declares the data types and implements the algorithms for
    type-checking of Go packages
\end{quote}\cite{godoc-types}

Though it will not have a direct impact on the compiler, adding the prepend function
to the \textit{types} package allows external tools like `gopls' (Go's official language
server)\cite{gopls} to type-check `.go' files and support the programmer
at writing code.

\subsubsection{Registering the function as a builtin}

To allow type-checking prepend, the function has to be registered as a builtin.
This is done in `\textit{src/go/types/universe.go}':

\begin{code}
    \captionof{listing}{public type-checking for prepend builtin (\textit{src/go/types/universe.go})}
    \gofilerange{../work/go/src/go/types/universe.go}{start}{end}
\end{code}

\begin{code}
    \captionof{listing}{list of predeclared functions (\textit{src/go/types/universe.go})}
    \gofilerange{../work/go/src/go/types/universe.go}{predecstart}{predecend}
\end{code}


Prepend takes two arguments and is not a variadic function. The expression kind can either be a `conversion',
`expression' or a `statement'.
prepend is an expression, similar to append, as it returns a value.

The type-checking that is implemented here is not related, in any way, to compiling
the source code to machine code, which will do its own type-checking. It is only
used for external tools.
To add the type-checking to prepend, a test has to be added too (a separate
test ensures that all builtins are type-checked).

\begin{code}
    \captionof{listing}{builtin functions tests (\textit{src/go/types/builtins\_test.go})}
    \gofilerange{../work/go/src/go/types/builtins_test.go}{start-builtin-tests}{end-builtin-tests}
\end{code}

The type-checking itself is straightforward. The implementation starts by checking that the second
argument is a slice, and then extracts the type and checks that the first argument is of the same type.

% TODO: line length?
\begin{code}
    \captionof{listing}{type checking prepend (\textit{src/go/types/builtins.go})}
    \gofilerange{../work/go/src/go/types/builtins.go}{start-prepend-typecheck}{end-prepend-typecheck}
\end{code}

This concludes the type-checking for external tools and makes `gopls' return errors
if the wrong types are used. For example, when trying to prepend an integer to
a string slice.

\begin{gocode}
package main

import "fmt"

func main() {
    fmt.Println(prepend(3, []string{"hello", "world"}))
}
\end{gocode}

Gopls then reports the type-checking error:
\begin{bashcode}
$ gopls check main.go
/tmp/playground/main.go:6:22-23: cannot convert 3 (untyped int constant) to string
\end{bashcode}

\subsubsection{Implementing the function in the compiler}

The compiler is implemented at \textit{src/cmd/compile/internal/gc},
so all mentioned files are located within this directory.

\newglossaryentry{dag}{name=DAG, description={Directed Acyclic Graph}}

First, prepend needs to be registered as a builtin to parse prepend into
the\gls{ast} (technically, the syntax tree is a syntax \gls{dag}\cite{ast-node-dag},
but this is an implementation detail):


\textit{universe.go}
\begin{gocode}
// ...omitted
var builtinFuncs = [...]struct {
    name string
    op   Op
}{
    {"append", OAPPEND},
    {"prepend", OPREPEND},
    // ...omitted
}
\end{gocode}

`OPREPEND' is an operation that has to be defined in \textit{syntax.go}:

\begin{gocode}
// Node ops.
const (
    OXXX Op = iota
    // ...omitted
    OAPPEND       // append(List); after walk, Left may contain elem type descriptor
    OPREPEND      // prepend(Left, Right)
    OBYTES2STR    // Type(Left) (Type is string, Left is a []byte)
    // ...omitted
)
\end{gocode}

This also shows that an `OPREPEND' node expects its arguments to be in `node.Left' and `node.Right', and not, like `OAPPEND', in `node.List'. This is achieved in
\textit{typecheck.go}. Before typechecking, a node's arguments are always
defined in `node.List`. In the implementation for `OPREPEND', the arguments are typechecked and parsed
into `node.Left' and `node.Right' by

\begin{gocode}
// typecheck the arguments, expand function arguments etc.
typecheckargs(n)
// twoarg ensures there's exactly two arguments and adds
// them to n.Left and n.Right
if !twoarg(n) ...
\end{gocode}

After `node.Left' and `node.Right' are populated, `node.Right'\'s type is checked to be
a slice, and `node.Left' is of the same element type as the slice.
The full typecheck is added as case within \textit{typecheck.go}:

\inputminted[
    linenos,
    numberfirstline,
    stepnumber=5,
    firstline=1579,
    lastline=1613,
    breaklines,
    breakanywhere,
    tabsize=2,
    gobble=1,
    bgcolor=bg,
]{go}{../work/go/src/cmd/compile/internal/gc/typecheck.go}

With this, type-checking prepend in the AST is implemented.
The next step in the Go compiler is escape analysis. This is similar
to the `OAPPEND' node, though `OPREPEND' always has only two arguments:

\textit{escape.go}
\inputminted[
    linenos,
    numberfirstline,
    stepnumber=5,
    firstline=814,
    lastline=820,
    breaklines,
    breakanywhere,
    tabsize=2,
    gobble=2,
    bgcolor=bg,
]{go}{../work/go/src/cmd/compile/internal/gc/escape.go}

The next phase within the compiler are AST transformations to
lower the AST to a more easily compilable form. The first call
is made to `order'. `order' reorders expressions and enforces the
evaluation order. For prepend, this is done by adding another `case'
expression within \mintinline{go}|func (o *Order) expr(n, lhs *Node) *Node|.
Again, this can be implemented similarly to append:

\textit{order.go}
\inputminted[
    linenos,
    numberfirstline,
    stepnumber=5,
    firstline=1182,
    lastline=1188,
    breaklines,
    breakanywhere,
    tabsize=2,
    gobble=1,
    bgcolor=bg,
]{go}{../work/go/src/cmd/compile/internal/gc/order.go}

The compiler now calls `walk' to do more AST transformations, for example replacing
nodes like `OAPPEND' with the actual implementation of the algorithm, in AST form.
This is where the logic for `OPREPEND' needs to be added too.
To recapitulate, the general algorithm for `prepend' is:
\begin{gocode}
dest := make([]<T>, 1, len(src)+1)
dest[0] = elem
return append(dest, src...)
\end{gocode}

The implementation within `walkprepend' reflects these lines of Go code, but
as AST nodes:

\textit{walk.go}
\inputminted[
    linenos,
    numberfirstline,
    stepnumber=5,
    firstline=2997,
    lastline=3036,
    breaklines,
    breakanywhere,
    tabsize=2,
    bgcolor=bg,
]{go}{../work/go/src/cmd/compile/internal/gc/walk.go}

This `walkprepend' function is called from `walkexpr'. Within `walkepr', it is called
only if the parent node is of the operation `OAS' or `OASOP', as prepend is an expression that always
returns a value, meaning it must be assigned back.

This concludes the implementation of prepend, though all changes can be found by comparing the
changes between the git tag `go1.14'\cite{ba-go-1-14} and `ba-added-prepend'\cite{ba-added-prepend}.
