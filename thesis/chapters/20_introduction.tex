% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

\section{Learning Functional Programming}

In 2007, C\# 3.0 was released. Two years later, Ryan Dhal published the initial version
of NodeJS, eliminating JavaScript's ties to the browser and introducing it as a server-side
programming language. In 2013, Java 8 was released. Within the same timeframe, Python
has been rapidly growing in popularity\autocite{python-popularity}.

What all these events have in common is that they brought along concepts from functional
programming, so far mainly used in academia, into the daily life of many programmers.

Further, many new multi-paradigm programming languages have been introduced,
including Rust, Kotlin, Go and Dart. They all have functions as first-class citizens in
the language since their initial release.

Functional programming has landed in the wider programming-community, emerging from niche use-cases
and academia.
For example Rust, the `most popular programming language' for 4 years in a row (2016--2019)
according to the StackOverflow Developer survey\autocite{rust-loved}, has been significantly
influenced by functional programming languages\autocite{rust-functional}. Further, in idiomatic
Rust code, a functional style can be clearly observed\footnote{A simple example for this may be
that variables are immutable by default}.

Learning a purely functional programming language increases fluency with these concepts and
teaches a different way to think and approach problems when programming. Due to this, many
people recommend learning a functional programming
language\autocite{blog1-funcprog}\autocite{blog2-funcprog}\autocite{blog3-funcprog}\autocite{blog4-funcprog},
even if one may not end up using that language at all\autocite{quora-funcprog}.

Even though the exact definition of what a \textit{purely} functional language is remains a
controversy\autocite{functional-controversy}, most literature about functional programming,
including academia and online resources like blogs, contain code examples written in Haskell.
Further, according to the Tiobe Index\autocite{tiobe-index}, Haskell is also the most popular
purely functional programming language\autocite{comparison-functional-languages}.

\section{Haskell}

Haskell, the \textit{lingua franca} amongst functional programmers, is a lazely-evaluated, purely functional programming
language. While Haskell's strengths stem from all it's features like type classes, type polymorphism, purity and more,
these features are also what makes Haskell famously hard to learn\autocite{haskell-hard-one}\autocite{haskell-hard-two}\autocite{haskell-hard-three}\autocite{haskell-hard-four}.

Beginner Haskell programmers face a very distinctive challenge in contrast to learning a new, non-functional programming language:
Not only do they need to learn a new language with an unusual syntax (compared to imperative or object-oriented languages), they
also need to change their way of thinking and reasoning about problems.
For example, the renowned quicksort-implementation from the Haskell Introduction Page\autocite{haskell-quicksort}:

\label{code:haskell-quicksort}
\begin{haskellcode}
quicksort :: Ord a => [a] -> [a]
quicksort []     = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs
\end{haskellcode}

While this is only a very short and clean piece of code, these 6 lines already pose many challenges to non-experienced Haskellers;

\begin{itemize}
    \item The function's signature with no `fn' or `func' statement as they often appear in imperative languages
    \item The pattern matching, which would be a `switch' statement or a chain of `if / else' conditions
    \item The deconstruction of the list within the pattern matching
    \item The functional nature of the program, passing `(< p)' (a function returning a function) to another function
    \item The function call to `filter' without paranthesised arguments and no clear indicator at which arguments
        it takes and which types are returned
\end{itemize}

Though some of these points are also available to programmers in imperative or object-oriented languages, the cumulative difference
is not to underestimate and adds to Haskell's steep learning curve.

\section{Goals}

Learning a new paradigm and syntax at the same time can be daunting and discouraging for novices.
By using a modern, multi-paradigm language with a clear and familiar syntax, the functional
programming beginner should be able to focus on the paradigm first, and then change to a language
like Haskell to fully get into functional programming.

To ease the learning curve of functional programming, this thesis will consist of two parts.
In the first part, writing functional code should be made as easy as possible. This means that
a language with an easy and familiar syntax should be chosen. Further, this programming language
should already support functions as first-class citizens. Additionally, it should be statically
typed, as a static type system makes it easier to reason about a program and can support the
programmer while writing code.
In the second part, a linter is created to check code for non-functional statements. To achieve
this, functional purity has to be defined, a ruleset has to be worked out and implemented into
a static analysis tool.

\section{Why Go}\label{sec:why-go}

The language of choice for this task is Go, a statically typed, garbage-collected programming language
designed at Google in 2009\autocite{golang-publish}. With its strong syntactic similarity to C, it should
be familiar to most programmers.

Go strives for simplicity and its syntax is extremely small and easy to learn. For example, the
language consists only of 25 keywords and purposefully omits constructs like the ternary operator
(<bool> ? <then> : <else>) as a replacement for the longer `if <bool> \{ <then> \} else \{ <else> \}' due
to clarity. `A language needs only one conditional control flow construct'\autocite{go-ternary},
and this also holds true for many other constructs. In Go, there is usually only one way
to express something, improving the clarity of code.

Due to this clarity and unambiguity, the language is a perfect fit to grasp the concepts and trace
the inner workings of functional programming. It should be easy to read code and understand what
it does without years of experience with the language.

There are however a few downsides of using Go. So far, Go does not have polymorphism, which means
that functions always have to be written with specific types. Due to this, Go also does not include
common list processing functions like `map', `filter', `reduce' and more\footnote{Although Go does
	have some polymorphic functions like `append', these are specified as built-in functions in the
language and not user-defined}. Further, Go does not have a built-in `list' datatype. However, Go's
`slices' cover a lot of use cases for lists already. Section~\ref{sec:go-slices} goes into more
details on slices.

\section{Existing Work}

With Go's support of some functional aspects, patterns and best practices have emerged that relate
to functional programming.
For example, in the \textit{net/http} package of the standard library, the function
\begin{gocode}
func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
\end{gocode}
is used to register functions for http server handling:

\begin{gocode}
func myHandler(w http.ResponseWriter, r *http.Request) {
    // Handle the given HTTP request
}

func main() {
    // register myHandler in the default ServeMux
    http.HandleFunc("/", myHandler)
    http.ListenAndServe(":8080", nil)
}
\end{gocode}
\autocite{go-http-doc}

Using functions as function parameters or return types is a commonly used feature in Go, not just
within the standard library.

\subsection{Functional Options}

A software design pattern that has gained popularity within the Go community is `functional options'.
The pattern has been outlined in Dave Cheney's blog post `Functional options for friendly APIs'
and is a great example on how to use the support for multiple paradigms.
The basic idea with functional options is that a type constructor receives an unknown (0-n) amount
of options:
\begin{gocode}
func New(requiredSetting string, opts ...option) *MyType {
	t := &MyType{
		setting: requiredSetting,
	}

	for _, opt := range opts {
		opt(t)
	}

	return t
}

type option func(t *MyType)
\end{gocode}

These options can then access the instance of \mintinline{go}|MyType| to modify it accordingly,
for example:

\begin{gocode}
func EnableFeatureX() option {
	return func(t *MyType) {
		t.featureX = true
	}
}
\end{gocode}

To enable feature X, `New' can be called with that option:
\begin{gocode}
t := New("required", EnableFeatureX())
\end{gocode}

With this pattern, it is easy to introduce new options without breaking old usages of the API.
Furthermore, the typical `config struct' pattern can be avoided and meaningful zero values
can be set.

A more extensive example on how functional options are implemented and used can be found in
appendix~\ref{appendix:funcopts}.

\begin{quote}
    In summary
    \begin{itemize}
        \item Functional options let you write APIs that can grow over time.
        \item They enable the default use case to be the simplest.
        \item They provide meaningful configuration parameters.
        \item Finally they give you access to the entire power of the language to initialize complex values.
    \end{itemize}\autocite{functional-options}
\end{quote}

While this is a great example of what can be done with support for functional concepts, a purely functional approach to
Go has so far been discouraged by the core Go team, which is understandable for a multi-paradigm programming language.
However, multiple developers have already researched and tested Go's ability to do functional programming.

\subsection{Functional Go?}

In his talk `Functional Go'\autocite{func-go-talk}, Francesc Campoy Flores analysed some commonly used functional
language features in Haskell and how they can be ported with Go. Ignoring speed and stackoverflows due to non-existent
tail call optimisation\autocite{go-tco}, the main issue was with the type system and the missing polymorphism.

\subsection{go-functional}

In July 2017, Aaron Schlesinger, a Go programmer for Micosoft Azure, gave a talk on functional programming wit Go.
He released a repository\autocite{go-functional} that contains `core utilities for functional Programming in Go'.
The project is currently unmaintained, but showcases functional programming concepts like currying, functors and
monoids in Go.
In the `README' file of the repository, he also states that:
\begin{quote}
    Note that the types herein are hard-coded for specific types, but you could
    use code generation to produce these FP constructs for any type you please!
    \autocite{go-functional-readme}
\end{quote}

\section{Conclusion}

The aforementioned projects showcase the main issue with functional programming in Go: the missing
helper functions that are prevalent in functional languages and that they currently cannot be implemented
in a generic way.

To make functional programming more accessible in Go, this thesis will research what the most used
higher-order functions are and implement them with a focus on usability.
Furthermore, a list of rules for pure functional should be curated and implmented in a linter. This
linter can then be used to check existing code and report constructs which are not functional.
