As discussed in Chapter~\ref{sec:funcheck-theory}, a linter needs to be written
to detect reassignments within a Go program.

To get a grasp about the issues this linter is trying to solve, we will % TODO
first write down some examples, cases that should be matched against.

\subsection{Examples}

The simplest cases are standalone reassignments and assignment operators:
\begin{gocode}
x := 5
x = 6 // forbidden
// or
var y = 5
y = 6   // forbidden
y += 6  // forbidden
y <<= 2 // forbidden
y++     // forbidden
\end{gocode}
Where the statement \mintinline{go}|x = 6| and \mintinline{go}|y = 6| should be reported.

Adding block scoping to this, shadowing the old variable needs to be allowed:
\begin{gocode}
x := 5
{
	x = 6  // forbidden, changing the old value
	x := 6 // allowed, as this shadows the old variable
}
\end{gocode}
What should be illegal is to declare the variable first and then assign a
value to it:
\begin{gocode}
var x int
x = 6 // forbidden
\end{gocode}
The exception here are functions, as they need to be declared first in order
to recursively call them:
\begin{gocode}
var f func()
f = func() {
	f()
}
\end{gocode}
Furthermore, the linter also needs to be able to handle multiple variables
at once:
\begin{gocode}
var f func()
x, f, y := 1, func() { f() }, 2
\end{gocode}

All the aforementioned examples and more can be found in the testcases for funcheck\autocite{funcheck-examples}.

\subsection{Building a linter}

The Go ecosystem already provides an official library for building code analysis tools,
the `analysis' package from the Go Tools repository\autocite{go-analysis}. With this package,
implementing a static code analyizer is being reduced to writing the actual AST node analysis.

To define an analysis, a variable of type \mintinline{go}|*analysis.Analyzer| has to be declared:

\begin{gocode}
var Analyzer = &analysis.Analyzer{
	Name: "assigncheck",
	Doc:  "reports re-assignments",
	Run:  func(*analysis.Pass) (interface{}, error)
}
\end{gocode}
The necessary steps are now adding the `Run' function and registering the analyser
in the \mintinline{go}|main()| function.

The `Run' function takes a `Pass' type. The Pass provides information about the package
that is being analysed and some helper-functions to report diagnostics.

With `analysis.Pass.Files` and the help of the `go/ast` package, traversing the syntax
tree of every file in a package is done % TODO:

\begin{gocode}
for _, file := range pass.Files {
	ast.Inspect(file, func(n ast.Node) bool {
		// node analysing here
	})
}
\end{gocode}
To implement funcheck as described, we need to %TODO
take care of three different AST node types. The first and easiest one is
\mintinline{go}|*ast.IncDecStmt|. An `IncDecStmt' node is a \mintinline{go}|x++|
or \mintinline{go}|x--| expression and should always be reported.

\begin{gocode}
switch as := n.(type) {
case *ast.IncDecStmt:
	pass.Reportf(as.Pos(), "inline re-assignment of %s", as.X)
}
\end{gocode}
The other two types are \mintinline{go}|*ast.DeclStmt| and \mintinline{go}|*ast.AssignStmt|.
They are not as simple to handle, which is why they are covered in their own chapters.

\subsubsection{Detecting reassignments}

To recapitulate, the goal of this step is to detect all assignments except blank identifiers
(discarded values cannot be mutated) and function literals, if the function is declared in the
last statement\footnote{This rule is to simplify the logic of the checker and make it easier
    for developers to read the code. It means that no code may be between \mintinline{go}|var f func|
and \mintinline{go}|f = func() { ... }|.}.

To detect such reassignments, funcheck iterates over all identifiers on the left-hand side
of an assignment statement.
All elements on the left-hand side that are not identifiers are reassignments and do not need
to be examined any more\footnote{For example, on the left-hand side of an assignment might be an
    \mintinline{go}|*ast.IndexExpr|, which indexes a slice or a map. However, these
can only be reassignments as they would not be allowed in a declaration}.

Every identifier (an AST node with type \mintinline{go}|*ast.Ident|) contains an object\footnote{`An
    object describes a named language entity such as a package, constant, type, variable,
function (incl. methods), or a label'\autocite{go-ast-object}.} that links to the declaration.

This declaration, of whatever type it may be, always has a position (and a corresponding function
to retrieve that position) in the source file.

A reassignment is detected when an identifier's declaration position does not match the assignment's
position.

This is illustrated in the code block~\ref{code:assign-pos}. What can be clearly seen is that in
the assignment \mintinline{go}|y = 3|, \mintinline{go}|y|'s declaration refers to the position
of the first assignment \mintinline{go}|x, y := 1, 2|, the position where \mintinline{go}|y| has
been declared.

\begin{code}
    \captionof{listing}{Illustration of an assignment node and corresponding positions\autocite{ast-positions}}
    \begin{gocode}
Assignment "x, y := 1, 2": 2958101
        Ident "x": 2958101
                Decl "x, y := 1, 2": 2958101
        Ident "y": 2958104
                Decl "x, y := 1, 2": 2958101
Assignment "y = 3": 2958115
        Ident "y": 2958115
                Decl "x, y := 1, 2": 2958101
    \end{gocode}
  \label{code:assign-pos}
\end{code}
As this technique works on an identifier level, multi-variable declarations or assignments
can be verified without any additional effort. If one variable in a short variable declaration
is being reassigned, the variable's `Declaration' field will point to the original position
of the declaration, which can be easily detected.

\subsubsection{Handling function declarations}

In contrast to all other variable types, function variables may be `reassigned' once.
As discussed in Chapter~\ref{func-reassign}, this is to allow recursive function
literals. Detecting and not reporting these assignments is a two-step process, as two
consecutive AST nodes need to be inspected.

The first step is to detect function declarations; statements of the form
\mintinline{go}|var f func() |. Should such a statement be encountered,
its position will be saved for the following AST node.

In the consecutive AST node it is ensured that if the node is an assignment and
the assignee identifier is of type function literal, the position matches the
previously saved one.

The position of the declaration and AST node structure can be seen in~\ref{code:func-reassign}

\begin{code}
    \captionof{listing}{Illustration of a function literal assignment\autocite{ast-positions}}
    \begin{gocode}
Declaration "var f func() int": 2958142
        Ident "f func() int": 2958146
Assignment "f = func() int { return y }": 2958160
        Ident "f": 2958160
                Decl "f func() int": 2958146
    \end{gocode}
    \label{code:func-reassign}
\end{code}
