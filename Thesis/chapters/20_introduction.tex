% -*- mode: latex; coding: utf-8; TeX-master: ../thesis -*-
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../thesis.tex

%\IfLanguageName{nswissgerman}{\section{Ausgangslage}}{\section{Starting point}}
%\label{sec:starting-point}

%\todo[inline]{%
  %\quad -- Nennt bestehende Arbeiten/Literatur zum Thema - Literaturrecherche \\
  %\quad -- Stand der Technik: Bisherige Lösungen des Problems und deren Grenzen \\
  %\quad -- (Nennt kurz den Industriepartner und/oder weitere Kooperationspartner und dessen/deren Interesse am Thema Fragestellung)
%}


%\IfLanguageName{nswissgerman}{\section{Zielsetzung}}{\section{Objective}}
%\label{sec:objective}

%\todo[inline]{%
  %\quad -- Formuliert das Ziel der Arbeit \\
  %\quad -- Verweist auf die offizielle Aufgabenstellung des/der Dozierenden im Anhang \\
  %\quad -- (Pflichtenheft, Spezifikation) \\
  %\quad -- (Spezifiziert die Anforderungen an das Resultat der Arbeit) \\
  %\quad -- (Übersicht über die Arbeit: stellt die folgenden Teile der Arbeit kurz vor) \\
  %\quad -- (Angaben zum Zielpublikum: nennt das für die Arbeit vorausgesetzte Wissen) \\
  %\quad -- (Terminologie: Definiert die in der Arbeit verwendeten Begriffe)
%}

\section{Learning Functional Programming}
When Python started to take off around 2010\cite{python-popularity},
it also brought with it the idea of functional programming. Since then, many new multi-paradigm
languages have appeared and gotten more popular, as for example Go, Rust,
Kotlin and Dart.
Most of the languages mentioned support an imperative, object-oriented, as well as functional programming style.
Rust, being the `most popular programming language'\cite{rust-loved} for 4 years in a row (2016--2019), has been
significantly influenced by functional programming languages\cite{rust-functional} and borrows a lot of functional
concepts in idiomatic Rust code.

Learning a functional programming language increases fluency with these concepts and teaches a different
way to think and approach problems when programming. For those reasons, and many more, a lot of programmers
advocate learning a functional programming language.

Though the exact definition of what a \textit{purely} functional language consists of remains a controversy\cite{functional-controversy},
the most popular programming language within that space seems to be Haskell\cite{comparison-functional-languages}.

\section{Haskell}

Haskell, the \textit{lingua franca} between functional programmers, is a lazely-evaluated, purely functional programming
language. While Haskell's strengths stem from all it's features like the type classes, type polymorphism, purity and more,
these features are also what makes Haskell famously hard to learn\cite{haskell-hard-one}\cite{haskell-hard-two}\cite{haskell-hard-three}\cite{haskell-hard-four}.

Beginner Haskell programmers face a very distinctive challenge in contrast to learning a new, non-functional programming language:
Not only do they need to learn a new language with an unusual syntax (compared to imperative or object-oriented languages), they
also need to change their way of thinking and reasoning about problems.
For example, the renowned quicksort-implementation from the Haskell Introduction Page\cite{haskell-quicksort}:

\begin{minted}{haskell}
quicksort :: Ord a => [a] -> [a]
quicksort []     = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs
\end{minted}

While this is only a very short and clean piece of code, these 6 lines already pose many challenges to non-experienced Haskellers;

\begin{itemize}
    \item The function's signature with no `fn' or `func' statement as they often appear in imperative languages
    \item The pattern matching, which would be a `switch' statement or a chain of `if / else' conditions
    \item The deconstruction of the list within the pattern matching
    \item The application of the `filter' function with no clear indicator at which arguments it takes and which types are returned
    \item The functional nature of the program, passing `(< p)' (a function) to another function
\end{itemize}

Though some of these points are also available to programmers in imperative or object-oriented languages, the cumulative difference
is not to underestimate and adds to Haskell's steep learning curve.

% TODO: talk about production-ready code and programmers?

\section{Goals}

The goal of this thesis is not to create a production-ready functional language. Rather, it will
try to solve the issue of the first steps in functional programming.
Learning a new paradigm and syntax at the same time can be daunting and discouraging for novices.
By using a modern, multi-paradigm language with a clear
and familiar syntax, the functional programming beginner should be able to focus on the paradigm
first, and then change to a language like Haskell to fully get into functional programming.

To ease the learning curve of functional programming, this thesis will consist of two parts:

\begin{itemize}
    \item Make a multi-paradigm language support functional programming as much as needed.
        The criteria for this language are:
    \begin{itemize}
        \item Easy, familiar syntax
        \item Be statically typed, as this makes it easier to reason about a program
        \item Have support for functional programming features like first class functions, currying
            and partial application
    \end{itemize}
    \item Create a linter that checks code on its functional purity. For this, some rules will have
        to be curated to define what pure functional code is.
\end{itemize}

\section{Why Go}

The language of choice for this task is Go, a statically typed, garbage-collected programming language
designed at Google in 2009\cite{golang-publish}. With its strong syntactic similarity to C, it should
be familiar to most programmers.
Go is an extremely verbose language with almost no syntactic sugar. This makes it a perfect fit to
grasp the concepts and trace the inner workings of functional programming.

There are, however, a few downsides of using Go:

\begin{itemize}
    \item No polymorphism. Go 2 will likely have support for polymorphism, but at the time of writing,
        there is no implementation available.
    \item Missing implementations for `map', `filter', `reduce' and more.
    \item No list implementation. Go has `slices', which are `views' on arrays, but
        no list datatype.
\end{itemize}

\subsection{Go Slices}

Go's Slices can be viewed as an abstraction over arrays, to mitigate some of the weaknesses of arrays
compared to lists.

\begin{quote}
    Arrays have their place, but they're a bit inflexible, so you don't see them too often in Go code.
    Slices, though, are everywhere. They build on arrays to provide great power and convenience.\cite{golang-slices}
\end{quote}

Slices can be visualised as a `struct' over an array:

\begin{minted}{go}
    type Slice struct {
        // the underlying "backing store" array
        array *[]T
        // the length of the slice / view on the array
        len   int
        // the capacity of the array from
        // the starting index of the slice
        cap   int
    }
\end{minted}

With the `append' function, elements can be added to a slice. Should the underlying array not have enough
capacity left to store the new elements, a new array will be created and the data from the old array will
be copied into the new one. This happens transparently to the user.

\subsubsection{Using Slices}

`head', `tail' `last' operations can be done with index expressions:

\begin{minted}{go}
s := []string{"first", "second", "third"}
head := s[0]
tail := s[1:]
last := s[len(s)]
\end{minted}

Adding elements or joining slices is achieved with `append':

\begin{minted}{go}
s := []string{"first", "second"}
s = append(s, "third", "fourth")
t := []string{"fifth", "seventh"}
s = append(s, t...)
// to prepend an element, one has to create a
// slice out of that element
s = append([]string{"zeroth"}, s...)
\end{minted}

Append is a variadic function, meaning it takes \textit{n} elements. If the slice is of type \textit{[]<T>},
the appended elements have to be of type \textit{<T>}.

To join two lists, the second list is expanded into
variadic arguments.

More complex operations like removing elements, inserting elements in the middle or finding
elements in a slice require helper functions, which have also been documented in Go's
Slice Tricks\cite{slice-tricks}.

\subsubsection{What is missing from Slices}

This quick glance at slices should clarify that, though the runtime characteristics of lists and slices
can differ, from a usage standpoint, what is possible with lists is also possible with slices.

However, what is missing from Go's slices are a lot of the classical list `helper' functions. In a typical program written in a functional
language, lists take a central role. This results in a number of helper functions\cite{haskell-list-funcs}
that currently do not exist in Go and would need to be implemented by the programmer.
With no support for polymorphism, the programmer would need to implement a function for every slice-type
that is used. The type
\mint{go}|[]int|
(read: a slice of integers) differs from
\mint{go}|[]string|
which means that a possible `map' function would have to be
written once to support slices of integers, once to support slices of strings, and a combination of these two:

\begin{minted}{go}
func mapIntToString(f func(int) string, []int) []string {}
func mapIntToInt(f func(int) int, []int) []int {}
func mapStringToInt(f func(string) int, []string) []int {}
func mapStringToString(f func(string) string, []string) []string {}
\end{minted}

With 7 base types (eliding the different `int' types like `int8', `uint16`, `int16', etc.), this would
mean $7^{2} = 49$ map functions just to cover these base types. Counting the different numeric
types into that equation (totally 19 distinct types\cite{go-basetypes}), would grow that number to $19^{2} = 361$ functions.

Though this code could be generated, it leaves out custom user-defined types, which would still
need to be generated separately.

To mitigate this point, the most common list-operations (in Go slice-operations) will be added to
the compiler, so that the programmer can use these functions on every slice-type.

\subsection{Existing Work}

\subsection{Issues with functional programming in Go}

\section{Work to be done} % TODO: rename...
